package twopc

import (
	"io"
	"time"

	pb "github.com/juntaki/transparent/twopc/pb"
)

type request struct {
	key         interface{}
	value       interface{}
	requestType pb.RequestType
}

type requestID uint64
type state int

const (
	stateInit  state = iota
	stateWait        // Coodinator only
	stateReady       // Attendee only
	stateAbort
	stateCommit
)

type member string
type Coodinator struct {
	request chan request
	message chan message
	summary map[member]message
	member  []member
	timeout time.Duration
	status  state
	current requestID
}

func (c *Coodinator) AttendCluster(stream pb.Cluster_AttendClusterServer) error {
	for {
		in, err := stream.Recv()
		if err == io.EOF {
			return nil

		}
		if err != nil {
			return err

		}
		key := serialize(in.Location)
		for _, note := range c.routeNotes[key] {
			if err := stream.Send(note); err != nil {
				return err
			}
		}
	}
}

func (c *Coodinator) Run() {
	for {
		c.Initialize()
		select {
		case r := <-c.request:
			commit := c.VoteRequest(r)
			if commit {
				c.GlobalCommit()
			} else {
				c.GlobalAbort()
			}
		}
	}
}

func (c *Coodinator) VoteRequest(r request) (commit bool) {
	c.status = stateWait

	message := message{
		messageType: messageVoteRequest,
		requestID:   c.current,
		payload:     r,
	}
	// send r request to all member
	commit = true
	for {
		select {
		case v := <-c.message:
			if v.messageType != messageVoteCommit &&
				v.messageType != messageVoteAbort &&
				v.requestID != c.current {
				break
			} else if v.messageType != messageVoteAbort {
				commit = false
			}
			c.summary[(v.payload.(votePayload)).member] = v
			if len(c.member) == len(c.summary) {
				return
			}
		case <-time.After(time.Millisecond * c.timeout):
			commit = false
			return
		}
	}
}

func (c *Coodinator) Initialize() {
	c.status = stateInit
	c.summary = make(map[member]message)
	c.current++
}
func (c *Coodinator) GlobalCommit() {
	c.status = stateCommit
}
func (c *Coodinator) GlobalAbort() {
	c.status = stateAbort
}

type Attendee struct {
	message chan message
	timeout time.Duration
	status  state
	current requestID
	request request
}

func (a *Attendee) Set() {
	a.Request()
}

func (a *Attendee) Run() {
	a.status = stateInit
	for {
		select {
		case m := <-a.message:
			switch m.messageType {
			case messageVoteRequest:
				if a.status != stateInit {
					// ignore
					break
				}
				if m.requestID != a.current {
					// attendee may miss the last request
					a.status = stateAbort
					a.VoteAbort(m)
					break
				}
				a.request = m.payload.(request)
				a.status = stateReady
				a.VoteCommit(m)
			case messageGlobalCommit:
				if a.status != stateReady ||
					m.requestID != a.current {
					// ignore
					break
				}
				a.status = stateCommit
				a.Commit()
				a.ACK()
			case messageGlobalAbort:
				if a.status != stateReady ||
					m.requestID != a.current {
					// ignore
					break
				}
				a.status = stateAbort
				a.ACK()
			}
			a.status = stateInit
			a.current++
		case messageGlobalRequest:

		case <-time.After(time.Millisecond * a.timeout):
			if a.status == stateReady {
				a.status = stateInit
				a.current++
			}
		}
	}
}

func (a *Attendee) Attend() {

}
func (a *Attendee) Request() {

}
func (a *Attendee) VoteCommit(v message) {
	// send votePayload to coodinator
}
func (a *Attendee) VoteAbort(v message) {
	// send votePayload to coodinator
}
func (a *Attendee) GlobalRequest(v message) message {
	return messageGlobalCommit
}
